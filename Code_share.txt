import os
import yaml
from datetime import datetime, timedelta
from airflow import DAG
from airflow.exceptions import AirflowException
import pytz
from jinja2 import Template, Environment, FileSystemLoader

def merge_configs(default_config, user_config):
    def recursive_merge(d, u):
        for k, v in u.items():
            if isinstance(v, dict):
                d[k] = recursive_merge(d.get(k, {}), v)
            else:
                d[k] = v
        return d
    return recursive_merge(default_config, user_config)

def parse_default_args(default_args):
    if 'start_date' in default_args:
        default_args['start_date'] = datetime.strptime(default_args['start_date'], '%Y-%m-%d')
    if 'retry_delay' in default_args:
        default_args['retry_delay'] = timedelta(minutes=int(default_args['retry_delay'].replace('m', '')))
    return default_args

def load_template(template_name):
    template_dir = 'path/to/operator_templates'  # Adjust the path as needed
    env = Environment(loader=FileSystemLoader(template_dir))
    return env.get_template(template_name)

def create_task(dag, operator):
    op_type = operator.get('type')
    op_id = operator.get('id')

    if not op_type or not op_id:
        raise AirflowException(f"Operator configuration is missing 'type' or 'id': {operator}")

    template = load_template(f"{op_type}.j2")
    task_code = template.render(operator=operator, dag=dag)
    
    local_vars = {}
    exec(task_code, globals(), local_vars)
    return local_vars[op_id]

def create_dag(dag_id, config_path):
    with open(config_path, 'r') as file:
        config = yaml.safe_load(file)

    default_config = config.get('dag', {})
    user_config = config.get('user_config', {}).get('dag', {})

    final_config = merge_configs(default_config, user_config)
    default_args = parse_default_args(final_config.get('default_args', {}))

    dag = DAG(
        dag_id=dag_id,
        description=final_config.get('description', 'A simple example DAG'),
        schedule_interval=final_config.get('schedule_interval', '@daily'),
        default_args=default_args,
        catchup=False
    )

    operators_config = config.get('operators', [])
    user_operators_config = config.get('user_config', {}).get('operators', [])
    operators_config.extend(user_operators_config)

    tasks = {op['id']: create_task(dag, op) for op in operators_config}

    for operator in operators_config:
        op_id = operator['id']
        dependencies = operator.get('dependencies', [])
        for dep in dependencies:
            if dep in tasks:
                tasks[dep] >> tasks[op_id]

    return dag, tasks, default_args

def serialize_default_args(default_args):
    args_str = "{\n"
    for key, value in default_args.items():
        if isinstance(value, datetime):
            if value.tzinfo is not None:
                value_str = f"datetime({value.year}, {value.month}, {value.day}, {value.hour}, {value.minute}, {value.second}, tzinfo=pytz.{value.tzinfo.zone})"
            else:
                value_str = f"datetime({value.year}, {value.month}, {value.day}, {value.hour}, {value.minute}, {value.second})"
        elif isinstance(value, timedelta):
            value_str = f"timedelta(days={value.days}, seconds={value.seconds})"
        else:
            value_str = repr(value)
        args_str += f"    '{key}': {value_str},\n"
    args_str += "}"
    return args_str

def serialize_python_callable(python_callable):
    if callable(python_callable):
        return f"{python_callable.__name__}"
    return repr(python_callable)

def generate_dag_file(dag_id, dag, tasks, default_args, output_directory):
    dag_file_path = os.path.join(output_directory, f"{dag_id}.py")
    with open(dag_file_path, 'w') as f:
        f.write("from airflow import DAG\n")
        f.write("from airflow.operators.bash import BashOperator\n")
        f.write("from airflow.operators.python import PythonOperator\n")
        f.write("from datetime import datetime, timedelta\n")
        f.write("import pytz\n\n")
        f.write(f"default_args = {serialize_default_args(default_args)}\n\n")
        f.write(f"dag = DAG(dag_id='{dag.dag_id}', default_args=default_args, description='{dag.description}', schedule_interval='{dag.schedule_interval}', catchup={dag.catchup})\n\n")
        
        for task_id, task in tasks.items():
            f.write(f"{task_id} = {task.__class__.__name__}(task_id='{task.task_id}', ")
            for key, value in task.params.items():
                if isinstance(value, str):
                    f.write(f"{key}='{value}', ")
                elif isinstance(value, timedelta):
                    f.write(f"{key}=timedelta(seconds={value.total_seconds()}), ")
                else:
                    f.write(f"{key}={value}, ")
            f.write(f"dag=dag)\n")
        
        for task_id, task in tasks.items():
            for downstream_task in task.downstream_task_ids:
                f.write(f"{task_id} >> {downstream_task}\n")

def generate_dags(config_directory, output_directory):
    os.makedirs(output_directory, exist_ok=True)
    for config_file in os.listdir(config_directory):
        if config_file.endswith('.yaml'):
            config_path = os.path.join(config_directory, config_file)
            dag_id = os.path.splitext(config_file)[0]
            dag, tasks, default_args = create_dag(dag_id, config_path)
            generate_dag_file(dag_id, dag, tasks, default_args, output_directory)

if __name__ == "__main__":
    config_directory = '/usr/local/airflow/dags/configurations/'  # Adjust the path as needed
    output_directory = '/usr/local/airflow/dags/generated_dags/'  # Adjust the path as needed
    generate_dags(config_directory, output_directory)





{{ operator.id }} = BashOperator(
    task_id='{{ operator.id }}',
    bash_command='{{ operator.bash_command }}',
    retries={{ operator.retries | default(1) }},
    retry_delay=timedelta(minutes={{ operator.retry_delay | default('5m') | replace('m', '') }}),
    dag=dag
)


{{ operator.id }} = PythonOperator(
    task_id='{{ operator.id }}',
    python_callable={{ operator.python_callable }},
    op_args={{ operator.op_args | default([]) }},
    retries={{ operator.retries | default(1) }},
    retry_delay=timedelta(minutes={{ operator.retry_delay | default('5m') | replace('m', '') }}),
    dag=dag
)


